<div class="p-3">
	<ng-template #displayErrorOverride>
		<div><span>{{errorOverride}}</span></div>
	</ng-template>

	<ng-template [ngIf]="!errorOverride" [ngIfElse]="displayErrorOverride">
		<!--Header message if there are multiple error messages-->
		<div class="mb-3" *ngIf="isMultiError"><strong>The following criteria needs to be satisfied:</strong></div>

		<!--The errors array adds choice errors and point errors together-->
		<ul [class.phd-multi-error]="isMultiError">
			<li *ngIf="hasRequiredChoice && !choice?.isRequired && !choice?.disabledByHomesite && !choice?.disabledByRelocatedMapping?.length">
				<span>Disabled due to a Required choice</span>
			</li>
			<li *ngIf="choice?.isRequired">
				<span>Required due to Homesite selection</span>
			</li>

			<li *ngIf="choice?.disabledByHomesite">
				<span>Disabled due to Homesite selection</span>
			</li>

			<li
				*ngIf="choice?.disabledByRelocatedMapping?.length">
				<span>Disabled due to option already on contract. Must deselect: </span>

				<span *ngFor="let c of choice.disabledByRelocatedMapping; let i = index;">
					<span *ngIf="i > 0"> and </span>
					<a class="phd-clickable phd-link phd-choice" (click)="onChoiceNav(c)">{{c |
						choiceIdToName | async }}</a>
				</span>
			</li>

			<!--Within each type of error is the disabledBy array which makes up a single line -->
			<li *ngFor="let e of errors; let i = index">

				<span>Disabled due to </span>

				<span *ngFor="let d of e.disabledBy; let di = index">
					<span *ngIf="di > 0"> or </span>

					<!-- Disabled due to lot choice conflict-->
					<span *ngIf="d.disabledByHomesite">
						Homesite selection
					</span>

					<!-- Rules with both Must Have and Must Not Have would be treated as either-or -->
					<span *ngIf="d.disabledByHomesite && d.mustHaves?.length > 0"> and </span>

					<!-- Split errors by whether they are Must Have or Must Not Have rules -->
					<ng-container *ngIf="d.mustHaves?.length > 0">
						<span *ngFor="let mustHave of d.mustHaves; let mh = index">
							<span *ngIf="mh > 0"> or </span>
							<span *ngFor="let p of mustHave.points; let pi = index">
								<span *ngIf="pi > 0"> and </span>
								<a class="phd-clickable phd-link phd-point" (click)="onPointNav(p)">{{p | pointIdToName | async }}</a>
							</span>
							<span *ngFor="let c of mustHave.choices; let ci = index">
								<span *ngIf="ci > 0"> and </span>
								<a class="phd-clickable phd-link phd-choice" (click)="onChoiceNav(c)">{{c | choiceIdToName | async }}</a>
							</span>
						</span>

						<span> selection requirement{{d.anyMultipleMustHaves ? 's' : ''}}</span>

					</ng-container>

					<!-- Rules with both Must Have and Must Not Have would be treated as either-or -->
					<span *ngIf="d.mustHaves?.length > 0 && d.mustNotHaves?.length > 0"> or </span>

					<!-- For Must Not Have rules, we flip the "and"/"or" verbiage -->
					<ng-container *ngIf="d.mustNotHaves?.length > 0">
						<span *ngFor="let mustNotHave of d.mustNotHaves; let mnh = index">
							<span *ngIf="mnh > 0"> and </span>
							<span *ngFor="let p of mustNotHave.points; let pi = index">
								<span *ngIf="pi > 0"> or </span>
								<a class="phd-clickable phd-link phd-point" (click)="onPointNav(p)">{{p | pointIdToName | async }}</a>
							</span>
							<span *ngFor="let c of mustNotHave.choices; let ci = index">
								<span *ngIf="ci > 0"> or </span>
								<a class="phd-clickable phd-link phd-choice" (click)="onChoiceNav(c)">{{c | choiceIdToName | async }}</a>
							</span>
						</span>

						<span> selection{{d.mustNotHaves.length > 1 ? 's' : ''}}</span>

					</ng-container>

				</span>

			</li>
		</ul>
	</ng-template>

</div>

